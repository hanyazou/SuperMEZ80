;
;	  THIS PROGRAM IS A SKELETAL OUTLINE FOR A 128-BYTE PRIMARY
;	BOOTSTRAP FOR AUTOMATICALLY BOOTING TO UCSD PASCAL (TM).
;	  SET THE CORRECT ORIGIN FOR THIS PROGRAM FOR YOUR SYSTEM, SET
;	'MSIZE' FOR THE APPROPRIATE NUMBER OF KILOBYTES OF RAM MEMORY
;	FOR YOUR SYSTEM, SET THE APPROPRIATE PARAMETERS DESCRIBING YOUR
;	DISK ENVIRONMENT AND FINALLY WRITE A VERY LOW LEVEL DISK READ
;	ROUTINE TO ALLOW READING IN THE SECONDARY BOOTSTRAP AND YOUR
;	CBIOS OFF THE DISK AND INTO RAM.
;	  THE PROGRAM 'CPMBOOT' ON THE UCSD PASCAL DISTRIBUTION DISK WILL
;	THEN USE THIS PROGRAM AND YOUR CBIOS TO GENERATE AN AUTOMATICALLY
;	BOOTING UCSD PASCAL SYSTEM.
;
;	ADAPTED FOR Z80SIM, AUGUST 2008, UDO MUNK
;
BOOT	EQU	8200H		; SECONDARY BOOTSTRAP LOADED HERE
MSIZE	EQU	64		; MEMORY SIZE FOR ASSEMBLY
BIAS	EQU	(MSIZE*1024)-01900H
CBIOS	EQU	1500H+BIAS	; ORIGIN POINT
SECNUM	EQU	16		; SECONDARY BOOTSTRAP IS 16 SECTORS LONG
SECSEC	EQU	3		; SECONDARY BOOTSTRAP ON THIS SECTOR
BIOSNUM	EQU	8		; CBIOS IS 8 SECTORS LONG
BIOSSEC	EQU	19		; CBIOS IS ON THIS SECTOR
BUFADDR	EQU	1000H		; READ BUFFER IN LOWER MEMORY
;
;	Z80SIM I/O PORTS
;
CONDAT	EQU	1		; console data port
DRIVE	EQU	10		; FDC # OF DRIVE
TRACK	EQU	11		; FDC # OF TRACK
SECTOR	EQU	12		; FDC # OF SECTOR
FDCOP	EQU	13		; FDC COMMAND
FDCST	EQU	14		; FDC STATUS
DMAL	EQU	15		; DMA ADDRESS LOW
DMAH	EQU	16		; DMA ADDRESS HIGH
;
	ORG	0		; WHATEVER IS RIGHT FOR YOUR SYSTEM
;
PBOOT:
	LD	HL,STARTMSG
	CALL	PRTMSG
	LD	HL,CBIOS	; CBIOS GOES HERE
	LD	SP,HL		; RESET THE STACK
	LD	D,BIOSNUM	; D - # OF SECTORS TO READ
	LD	E,BIOSSEC	; E - STARTING SECTOR
	CALL	READIT		; READ IN CBIOS

	LD	HL,DEBUGMSG
	CALL	PRTMSG

	LD	HL,BOOT		; LOAD BOOT BASE ADDRESS
	LD	D,SECNUM	; D - # OF SECTORS TO READ
	LD	E,SECSEC	; E - STARTING SECTOR
	CALL	READIT		; READ IN SECONDARY BOOTSTRAP

	LD	HL,DEBUGMSG
	CALL	PRTMSG

	LD	HL,BOOTMSG
	CALL	PRTMSG
	LD	HL,JUMPMSG
	CALL	PRTMSG

	LD	HL,128		; MAXIMUM NUMBER OF BYTES PER SECTOR
	PUSH	HL
	LD	HL,26		; MAXIMUM NUMBER OF SECTORS IN TABLE
	PUSH	HL
	LD	HL,0		; TRACK-TO-TRACK SKEW
	PUSH	HL
	LD	HL,1		; FIRST INTERLEAVED TRACK
	PUSH	HL
	LD	HL,1		; 1:1 INTERLEAVING
	PUSH	HL
	LD	HL,128		; BYTES PER SECTOR
	PUSH	HL
	LD	HL,26		; SECTORS PER TRACK
	PUSH	HL
	LD	HL,77		; TRACKS PER DISK
	PUSH	HL
	LD	HL,CBIOS-2	; TOP OF MEMORY (MUST BE WORD BOUNDARY)
	PUSH	HL
	LD	HL,0100H	; BOTTOM OF MEMORY
	PUSH	HL
	LD	DE,CBIOS+3	; START OF THE SBIOS (JMP WBOOT)
	PUSH	DE
	PUSH	HL		; STARTING ADDRESS OF INTERPRETER
	JP	BOOT		; ENTER SECONDARY BOOTSTRAP


ERRMSG:
	DEFM	'BOOT: error booting'
	DEFB	13,10,0
STARTMSG:
	DEFM	'BOOT: read sectors ...'
	DEFB	13,10,0
BOOTMSG:
	DEFM	'BOOT: read sectors ... done'
	DEFB	13,10,0
DEBUGMSG:
	DEFB	13,10
	DEFM	'BOOT: ########################'
	DEFB	13,10
	DEFB	13,10,0
JUMPMSG:
	DEFB	13,10
	DEFM	'ENTER TO THE SECOND BOOT'
	DEFB	13,10
	DEFB	13,10,0
CKSUMMSG:
	DEFM	'CHECKSUM: '
	DEFB	0
HEXCHARS:
	DEFM	'0123456789ABCDEF'

PRTMSG:
	LD	A,(HL)
	OR	A
	RET	Z
	OUT	(CONDAT),A
	INC	HL
	JP	PRTMSG

PRTHEX:
	PUSH	BC
	PUSH	DE
	PUSH	HL
        LD	B,0

        LD	D,A
	SRL	A
	SRL	A
	SRL	A
	SRL	A
        LD	HL,HEXCHARS
        LD	C,A
        ADD	HL,BC
	LD	A,(HL)
	OUT	(CONDAT),A

	LD	A,D
        AND	A,0FH
        LD	C,A
        LD	HL,HEXCHARS
        ADD	HL,BC
	LD	A,(HL)
	OUT	(CONDAT),A

	POP	HL
	POP	DE
	POP	BC
        RET

HEXDUMP:
	PUSH	HL
	PUSH	DE
	PUSH	IX
	LD	D,A
        LD	IX,HL
        LD	E,0

HEXDUMP_REPEAT:
	LD	A,'Z'
	OUT	(CONDAT),A
	LD	A,'8'
	OUT	(CONDAT),A
	LD	A,'0'
	OUT	(CONDAT),A
	LD	A,':'
	OUT	(CONDAT),A
	LD	A,' '
	OUT	(CONDAT),A
	LD	HL,IX
        LD	A,H
        CALL	PRTHEX
        LD	A,L
        CALL	PRTHEX
	LD	A,':'
	OUT	(CONDAT),A
	LD	A,' '
	OUT	(CONDAT),A

HEXDUMP_REPEAT2:
	LD	A,(IX)
	ADD	A,E		; CALCULATE 8-BIT CHECKSUM
	LD	E,A
	LD	A,(IX)
	INC	IX
	CALL	PRTHEX
	LD	A,' '
	OUT	(CONDAT),A

	DEC	D
	JP	Z,HEXDUMP_END

	LD	A,D
	AND	A,0FH
	CP	A,0
	JP	NZ,HEXDUMP_REPEAT2

	LD	A,13
	OUT	(CONDAT),A
	LD	A,10
	OUT	(CONDAT),A

	JP	HEXDUMP_REPEAT

HEXDUMP_END:
	LD	HL,CKSUMMSG
        CALL	PRTMSG
	LD	A,E
	CALL	PRTHEX
	LD	A,13
	OUT	(CONDAT),A
	LD	A,10
	OUT	(CONDAT),A
	POP	IX
	POP	DE
	POP	HL
	RET
	

;
;	  READIT MUST READ THE NUMBER OF SECTORS SPECIFIED IN THE D
;	REG, STARTING AT THE SECTOR SPECIFIED IN THE E REG, INTO THE
;	MEMORY LOCATION SPECIFIED IN THE HL PAIR.
;
READIT:	
;
;  PUT YOUR CODE IN HERE
;
	XOR	A		; SELECT DRIVE 0
	OUT	(DRIVE),A
	OUT	(TRACK),A	; SELECT TRACK 0
L1:
	LD	A,E		; SELECT SECTOR
	OUT	(SECTOR),A
	LD	BC,BUFADDR	; READ BUFFER
	LD	A,C		; SET DMA ADDRESS LOW
	OUT	(DMAL),A
	LD	A,B		; SET DMA ADDRESS HIGH
	OUT	(DMAH),A
	XOR	A		; READ SECTOR
	OUT	(FDCOP),A
	IN	A,(FDCST)	; GET STATUS OF FDC
	OR	A		; READ SUCCESSFULL?
	JP	Z,L2		; YES, CONTINUE

	LD	HL,ERRMSG
	CALL	PRTMSG

	DI			; FAILURE, HALT CPU
	HALT
L2:
	; COPY READ SECTOR FROM BUFFER TO DESTINATION
	LD	A,128		; 128 BYTES PER SECTOR
	LD	IX,BUFADDR	; READ BUFFER
L3:
	LD	B,(IX)		; COPY ONE BYTE
	LD	(HL),B
	INC	HL		; INCREMENT ADDRESSES
	INC	IX
	DEC	A		; ALL 128 BYTES WERE COPIED?
	JP	NZ,L3		; NO, REPEAT TO COPY NEXT BYTE

	; DUMP READ SECTOR
	LD	BC,128
	SUB	HL,BC
	LD	A,128
	CALL	HEXDUMP
	ADD	HL,BC

	DEC	D		; SECTORS = SECTORS - 1
	RET	Z		; RETURN IF ALL SECTORS LOADED
	INC	E		; NEXT SECTOR TO READ
	JP	L1		; GO READ NEXT
;
	END	
